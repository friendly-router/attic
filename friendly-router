#!/usr/bin/env perl
######################################################################
# friendly-router database frontend.
#
# --------------------------------------------------------------------
#
# this script need:
#   - YAML (required for database management)
#   - JSON (required only for JSON converter)
#   - dbi (required only for SQL converter)
#
# --------------------------------------------------------------------
#
# future usage description:
#   friendly-router [create|update|delete] \
#                   [product|reseller|manufacturer|os] \
#                   --name Name [--extra-options]
#   friendly-router validate yaml
#   friendly-router generate sql
#   friendly-router generate json
#
######################################################################

use strict;
use warnings;

my $opts = { debug => 1 };

######################################################################
# log package, share accross all object, contain default logging
# function.
######################################################################
{ package _log;
  use strict;
  use warnings;

  sub debug {
      if ($opts->{debug}) {
	  my $self = shift();
	  my $string = shift();
	  printf(STDERR "debug: %s " . $string . "\n", $self, @_);
      }
  }
  
  1; }

######################################################################
# _wrapper package make easy hard things and defined lot for playing
# with perl datastructure
######################################################################
{ package _wrapper;
  use strict;
  use warnings;
  use parent -norequire, "_log";

  # simple constructor
  sub new {
      my $class = shift();
      my $self = { @_ };
      return bless($self, $class);
  }

  # this method is the recursive API.
  # with arity 1: only navigate throught datastructure
  # with arity 2: add callback function.
  sub recursive {
      my $self = shift();
      my $data = shift();
      my $callback = shift();
      
      unless ($callback) {
	  $self->type_switch($data, 0);
      }
      else {
	  $self->type_switch($data, 0, $callback);
      }
  }

  # type_switch method route data structure based
  # on their types.
  sub type_switch {
      my $self = shift();
      my $ref = shift();
      my $level = shift();
      my $callback = shift();
      
      my $type = ref($ref);
      if ($type eq "HASH") {
	  $self->hash($ref, $level+1, $callback);
      }
      elsif ($type eq "ARRAY") {
	  $self->array($ref, $level, $callback);
      }
      elsif ($type eq "SCALAR") {
	  # $self->debug("%s", $ref);
      }
      else {
	  # $self->debug("%s", $ref);
      }
  }

  # map action for array type
  sub array {
      my $self = shift();
      my $array = shift();
      my $level = shift();
      my $callback = shift();
      
      foreach my $item (@$array) {
	  printf("%s\n", $item);
	  unless($callback) {
	      $self->type_switch($item, $level);
	  }
	  else {
	      &$callback($item, $level, $callback);
	      $self->type_switch($item, $level, $callback);
	  }
      }
      return 0
  }

  # map action for hash type
  sub hash {
      my $self = shift();
      my $hash = shift();
      my $level = shift();
      my $callback = shift();
      
      foreach my $key (keys %$hash) {
	  my $value = $hash->{$key} || "undefined";
	  printf("%d, %s: %s\n", $level, $key, $value);
	  unless ($callback) {
	      $self->type_switch($hash->{$key}, $level);
	  }
	  else {
	      &$callback($key, $level, $callback);
	      $self->type_switch($hash->{$key}, $level, $callback);
	  }
      }
      return 0
  }

  1; }

{ package _wrapper::valid;
  use parent -norequire, "_wrapper";
  
  1; }

{ package _wrapper::create;
  use parent -norequire, "_wrapper";

  1; }

{ package _wrapper::read;
  use parent -norequire, "_wrapper";

  sub all {
      my $data = shift();
      my $wrapper = _wrapper->new();
      $wrapper->recursive($data);
  }
  
  1; }

{ package _wrapper::update;
  use parent -norequire, "_wrapper";
  1; }

{ package _wrapper::delete;
  use parent -norequire, "_wrapper";
  1; }

######################################################################
#
######################################################################
{ package _os;
  1; }

{ package _os::create;
  use parent -norequire, "_wrapper::create";
  
  1; }

######################################################################
#
######################################################################
{ package _product;
  1; }

######################################################################
#
######################################################################
{ package _reseller;
  1; }

######################################################################
#
######################################################################
{ package _manufacturer;
  1; }

######################################################################
#
######################################################################
{ package _usage;
  1; }

######################################################################
#
######################################################################
{ package main;
  use strict;
  use warnings;
  use YAML;

  sub return_keys {
      return keys(%$_);
  }

  if ($ARGV[0] && -f $ARGV[0]) {
      open(my $fh, "<", $ARGV[0]);
      my @list = Load(join("", <$fh>));
      close($fh);
      my $callback = sub { printf("callback: %s\n", $_[0]) };
      _wrapper::read->recursive(\@list, $callback);
      print("\n");
  }

  1; }
