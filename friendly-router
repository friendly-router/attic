#!/usr/bin/env perl
######################################################################
# friendly-router database frontend.
#
# --------------------------------------------------------------------
#
# this script need:
#   - YAML (required for database management)
#   - JSON (required only for JSON converter)
#   - dbi (required only for SQL converter)
#
# --------------------------------------------------------------------
#
# future usage description:
#   friendly-router [create|update|delete] \
#                   [product|reseller|manufacturer|os] \
#                   --name Name [--extra-options]
#   friendly-router validate yaml
#   friendly-router generate sql
#   friendly-router generate json
#
######################################################################

use strict;
use warnings;

my $opts = { debug => 1 };

######################################################################
# log package, share accross all object, contain default logging
# function.
######################################################################
{ package _log;
  use strict;
  use warnings;

  sub debug {
      if ($opts->{debug}) {
	  my $self = shift();
	  my $string = shift();
	  printf(STDERR "debug: %s " . $string . "\n", $self, @_);
      }
  }
  
  1; }

######################################################################
# _wrapper package make easy hard things and defined lot for playing
# with perl datastructure
######################################################################
{ package _wrapper;
  use strict;
  use warnings;
  use YAML;
  use parent -norequire, "_log";

  # simple constructor
  sub new {
      my $class = shift();
      my $self = { @_ };
      bless($self, $class);
      return $self;
  }

  # this method is the recursive API.
  # with arity 1: only navigate throught datastructure
  # with arity 2: add callback function.
  sub recursive {
      my $self = shift();
      my ($value, $callback, $state) = @_;
      return $self->type_switch($value, 0, $callback, $state);
  }

  # type_switch method route data structure based
  # on their types.
  sub type_switch {
      my $self = shift();
      my ($value, $level, $callback, $state) = @_;
      my $type = ref($value);

      if ($type) {
	  &$callback($value, $level, $state);
	  $self->$type($value, $level, $callback, $state);
      }
      else {
	  printf("%s\n", $value);
      }
      return $state;
  }

  sub REF {
      my $self = shift();
      my ($ref, $level, $callback, $state) = @_;
      $self->type_switch(\$ref, $level, $callback, $state);
  }
  
  # map action for array type
  sub ARRAY {
      my $self = shift();
      my ($array, $level, $callback, $state) = @_;
      
      foreach my $item (@$array) {
	  $self->type_switch($item, $level, $callback, $state);
      }
      return 0
  }

  # map action for hash type
  sub HASH {
      my $self = shift();
      my ($hash, $level, $callback, $state) = @_;
      my @keys = keys %$hash;

      foreach my $key (@keys) {
	  my $value = $hash->{$key} || "undefined";
	  $self->type_switch($value, $level+1, $callback, $state);
      }
      return 0
  }

  sub SCALAR {
      my $self = shift();
      printf("%s\n", join(" ", @_));
  }
  
  sub load_template {
      my $self = shift();
      my $template = Load($self->{template});
  }

  
  1; }

######################################################################
#
######################################################################
{ package _os;

  sub new {
      my $class = shift();
      my $self = {};
      bless($self, $class);
      $self->load_template();
      return $self;
  }
  
  sub load_template {
      my $self = shift();
      my $template = "./yaml/os.template";
      $self->{template} = Load($template);
      return $self;
  }
  
  sub create {
      my $self = shift();
      
      
  }
  
  1; }


######################################################################
#
######################################################################
{ package _product;
  1; }

######################################################################
#
######################################################################
{ package _reseller;
  1; }

######################################################################
#
######################################################################
{ package _manufacturer;
  1; }

######################################################################
#
######################################################################
{ package _database;
  use strict;
  use warnings;
  use YAML;
    
  1; }

{ package _fsm;
  use strict;
  use warnings;
  use parent -norequire, "_log";
  
  sub new {
      my $class = shift();
      my $origin = shift();
      my $callback = shift();
      my $self = { };
      bless($self, $class);
      return $self->set_data($origin)->set_callback($callback);
  }

  sub set_data {
      my $self = shift();
      my $data = shift() || 0;
      $self->{origin} = $data;
      return $self;
  }
  
  sub set_callback {
      my $self = shift();
      my $callback = shift() || 0;
      $self->{callback} = $callback;
      return $self;
  }

  sub callback {
      my $self = shift();
      my $callback = $self->{callback};
      if ($callback) {
	  return &$callback(@_);
      }
      return ();
  }
  
  sub parse {
      my $self = shift();
      my $data = shift() || $self->{origin} or
	  die("no datastructure set.");
      
      my $ret = $self->router($data, @_);
      return $self;
  }

  sub router {
      my $self = shift();
      my $data = shift();
      my $ref = ref($data);
      
      if ($ref) {
	  $self->router_branch($ref, $data, @_);
      }
      else {
	  $self->router_leaf("LEAF", $data, @_);
      }
  }

  sub router_branch {
      my $self = shift();
      my $ref = shift();
      my $data = shift();
      
      my @retcall = $self->callback($ref, $data, @_);
      
      if (@retcall) {
	  $self->$ref(@retcall);
      }
      else {
	  $self->$ref($data, @_);
      }
  }
  
  sub router_leaf {
      my $self = shift();
      my $ref = shift();
      my $data = shift();
      return $self->callback($ref, $data, @_);
  }
  
  sub SCALAR {
      my $self = shift();
      my $data = shift();
      
      $self->debug("scalar: %s", $data);
      $self->router($data, @_);
  }
  
  sub HASH {
      my $self = shift();
      my $data = shift();

      my @keys = keys(%$data);
      foreach my $key (@keys) {
	  my $value = $data->{$key};
	  $self->debug("hash: %s -> %s", $key, $value);
	  $self->router($value, @_);
      }
  }
  
  sub ARRAY {
      my $self = shift();
      my $data = shift();
      my $limit = scalar(@$data);
      
      foreach my $position (0..$limit) {
	  my $value = $data->[$position];
	  $self->router($value, @_);
      }
  }
  
  sub REF {
      my $self = shift();
      my $data = shift();
      
      $self->debug("ref: %s", $data);
      $self->router($$data, @_);
  }
  
  sub CODE {
      my $self = shift();
      my $data = $self;
      
      $self->debug("code: %s", $data);
  }
  
  sub GLOB {
      my $self = shift();
      my $data = shift();
      
      $self->debug("glob: %s", <$data>);
      $self->router(<$data>, @_);
  }
    
  1; }

######################################################################
#
######################################################################
{ package _usage;
  
  1; }

######################################################################
#
######################################################################
{ package main;
  use strict;
  use warnings;
  use YAML;

  sub return_keys {
      return keys(%$_);
  }
  
  open(my $fd, "<", "./yaml/os/os.yaml");
  my $yaml = join("", <$fd>);
  my @data = Load($yaml);
  my $fsm = _fsm->new(\@data)->parse();
  close($fd);  
  
  1; }
